import std.error;

extern fn rt_str_len(value: Str) -> u64;
extern fn rt_str_get_u8(value: Str, index: i64) -> u8;
extern fn rt_str_slice(value: Str, begin: i64, end: i64) -> Str;
extern fn rt_str_from_char(value: u8) -> Str;

extern fn rt_strbuf_new(capacity: u64) -> StrBuf;
extern fn rt_strbuf_reserve(value: StrBuf, new_capacity: u64) -> unit;
extern fn rt_strbuf_len(value: StrBuf) -> u64;
extern fn rt_strbuf_get_u8(value: StrBuf, index: i64) -> u8;
extern fn rt_strbuf_set_u8(value: StrBuf, index: i64, byte: u8) -> unit;
extern fn rt_strbuf_to_str(value: StrBuf) -> Str;

export class Str
{
    fn len() -> u64 {
        return rt_str_len(__self);
    }

    fn get_u8(index: i64) -> u8 {
        var resolved: i64 = index;
        if resolved < 0 {
            resolved = (i64)__self.len() + resolved;
        }
        return rt_str_get_u8(__self, resolved);
    }

    fn slice(begin: i64, end: i64) -> Str {
        var resolved_begin: i64 = begin;
        if resolved_begin < 0 {
            resolved_begin = (i64)__self.len() + resolved_begin;
        }

        var resolved_end: i64 = end;
        if resolved_end < 0 {
            resolved_end = (i64)__self.len() + resolved_end;
        }

        return rt_str_slice(__self, resolved_begin, resolved_end);
    }

    fn strip() -> Str {
        var start: i64 = 0;
        var stop: i64 = (i64)__self.len();

        while start < stop {
            var c: u8 = __self[start];
            if (c == ' ' || c == '\n' || c == '\r' || c == '\t') {
                start = start + 1;
                continue;
            }
            break;
        }

        while start < stop {
            var c: u8 = __self[stop - 1];
            if (c == ' ' || c == '\n' || c == '\r' || c == '\t') {
                stop = stop - 1;
                continue;
            }
            break;
        }

        return __self[start:stop];
    }

    fn to_u64() -> u64 {
        var length: u64 = __self.len();
        if length == 0u {
            panic("Str.to_u64 on empty string");
        }
        var out: u64 = 0u;
        var i: u64 = 0u;
        while i < length {
            var ch: u8 = __self[(i64)i];
            if ch < '0' || ch > '9' {
                panic("Str.to_u64 invalid digit");
            }
            var digit: u64 = (u64)(ch - '0');
            if (out > 1844674407370955161u) || (out == 1844674407370955161u && digit > 5u) {
                panic("Str.to_u64 overflow");
            }
            out = out * 10u + digit;
            i = i + 1u;
        }
        return out;
    }

    static fn from_char(value: u8) -> Str {
        return rt_str_from_char(value);
    }
}

export class StrBuf
{
    static fn new(capacity: u64) -> StrBuf {
        return rt_strbuf_new(capacity);
    }

    static fn from_str(in_str: Str) -> StrBuf {
        var length: i64 = (i64) in_str.len();
        var out_buf: StrBuf = StrBuf.new((u64) length);

        var i: i64 = 0;
        while i < length {
            rt_strbuf_set_u8(out_buf, i, in_str[i]);
        }
        return out_buf;
    }

    fn len() -> u64 {
        return rt_strbuf_len(__self);
    }

    fn reserve(new_capacity: u64) -> StrBuf {
        rt_strbuf_reserve(__self, new_capacity);
        return __self;
    }

    fn to_str() -> Str {
        return rt_strbuf_to_str(__self);
    }

    fn get_u8(index: i64) -> u8 {
        var resolved: i64 = index;
        if resolved < 0 {
            resolved = (i64)__self.len() + resolved;
        }
        return rt_strbuf_get_u8(__self, resolved);
    }

    fn set_u8(index: i64, byte: u8) -> StrBuf {
        var resolved: i64 = index;
        if resolved < 0 {
            resolved = (i64)__self.len() + resolved;
        }
        rt_strbuf_set_u8(__self, resolved, byte);
        return __self;
    }
}

