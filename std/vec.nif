import std.error;

export class Vec
{
    private _len: u64;
    private _capacity: u64;
    private _storage: Obj[];

    static fn new() -> Vec {
        return Vec.with_capacity(4u);
    }

    static fn with_capacity(capacity: u64) -> Vec {
        if capacity < 1u {
            capacity = 1u;
        }

        return Vec(0u, capacity, Obj[](capacity));
    }

    fn len() -> u64 {
        return __self._len;
    }

    private fn _grow(min_capacity: u64) -> unit {
        if __self._capacity >= min_capacity {
            return;
        }

        var next_capacity: u64 = __self._capacity;
        if next_capacity < 1u {
            next_capacity = 1u;
        }

        while next_capacity < min_capacity {
            next_capacity = next_capacity * 2u;
        }

        var next_storage: Obj[] = Obj[](next_capacity);
        var i: i64 = 0;
        while i < (i64)__self._len {
            next_storage[i] = __self._storage[i];
            i = i + 1;
        }

        __self._storage = next_storage;
        __self._capacity = next_capacity;
    }

    private fn _normalize_index(index: i64) -> i64 {
        var len_i64: i64 = (i64)__self._len;
        if index < 0 {
            index = len_i64 + index;
        }
        return index;
    }

    fn push(value: Obj) -> unit {
        __self._grow(__self._len + 1u);
        __self._storage[(i64)__self._len] = value;
        __self._len = __self._len + 1u;
    }

    fn get(index: i64) -> Obj {
        index = __self._normalize_index(index);
        if index < 0 || index >= (i64)__self._len {
            panic("Vec.get: index out of bounds");
        }
        return __self._storage[index];
    }

    fn set(index: i64, value: Obj) -> unit {
        index = __self._normalize_index(index);
        if index < 0 || index >= (i64)__self._len {
            panic("Vec.set: index out of bounds");
        }
        __self._storage[index] = value;
    }

    fn slice(begin: i64, end: i64) -> Vec {
        begin = __self._normalize_index(begin);
        end = __self._normalize_index(end);

        if begin < 0 || end < begin || (u64)end > __self._len {
            panic("Vec.slice: invalid slice range");
        }

        var out: Vec = Vec.with_capacity((u64)(end - begin));
        var i: i64 = begin;
        while i < end {
            out.push(__self._storage[i]);
            i = i + 1;
        }
        return out;
    }
}
