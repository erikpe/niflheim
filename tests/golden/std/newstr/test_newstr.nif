import std.test;
import std.io;
import std.newstr;


fn test_baseline_get_set_slice() -> unit {
    var s: Str = "abcd";
    assert(s.len() == 4u);
    assert(s[0] == 'a');
    assert(s[-1] == 'd');

    s[1] = 'Z';
    assert(s[1] == 'Z');

    var mid: Str = s[1:3];
    assert(mid.len() == 2u);
    assert(mid[0] == 'Z');
    assert(mid[1] == 'c');

    var word: Str = "foobar";
    word[2] = 'x';
    assert(word[0] == 'f');
    assert(word[1] == 'o');
    assert(word[2] == 'x');
    assert(word[3] == 'b');
    assert(word[4] == 'a');
    assert(word[5] == 'r');
}


fn test_strip() -> unit {
    var s: Str = " \tA\n ";
    var t: Str = s.strip();
    assert(t.len() == 1u);
    assert(t[0] == 'A');
}


fn test_numeric_parse_ok() -> unit {
    assert(("18446744073709551615").to_u64() == 18446744073709551615u);
    assert(("-9223372036854775808").to_i64() == -9223372036854775808);
    assert(("9223372036854775807").to_i64() == 9223372036854775807);
}


fn test_from_u8_array() -> unit {
    var bytes: u8[] = u8[](3u);
    bytes[0] = 'A';
    bytes[1] = 'B';
    bytes[2] = 'C';

    var s: Str = Str.from_u8_array(bytes);
    bytes[0] = 'Z';
    assert(s.len() == 3u);
    assert(s[0] == 'A');
    assert(s[2] == 'C');
}


fn test_newstrbuf_baseline() -> unit {
    var s: Str = "foobar";
    var buf: StrBuf = StrBuf.from_newstr(s);

    assert(buf.len() == 6u);
    assert(buf[0] == 'f');
    assert(buf[-1] == 'r');

    buf[2] = 'x';
    assert(buf[2] == 'x');

    var mid: StrBuf = buf[1:4];
    assert(mid.len() == 3u);
    assert(mid[0] == 'o');
    assert(mid[1] == 'x');
    assert(mid[2] == 'b');

    var out: Str = buf.to_newstr();
    assert(out[0] == 'f');
    assert(out[1] == 'o');
    assert(out[2] == 'x');
    assert(out[3] == 'b');
    assert(out[4] == 'a');
    assert(out[5] == 'r');
}


fn test_newstrbuf_get_oob_panics() -> unit {
    var buf: StrBuf = StrBuf.new(0u);
    var c: u8 = buf[0];
}


fn test_newstrbuf_append_char() -> unit {
    var buf: StrBuf = StrBuf.new(1u);
    buf.append_char('f').append_char('o').append_char('o').append_char('b').append_char('a').append_char('r');

    assert(buf.len() == 6u);
    assert(buf[0] == 'f');
    assert(buf[1] == 'o');
    assert(buf[2] == 'o');
    assert(buf[3] == 'b');
    assert(buf[4] == 'a');
    assert(buf[5] == 'r');

    var out: Str = buf.to_newstr();
    assert(out[0] == 'f');
    assert(out[1] == 'o');
    assert(out[2] == 'o');
    assert(out[3] == 'b');
    assert(out[4] == 'a');
    assert(out[5] == 'r');
}


fn test_get_oob_panics() -> unit {
    var s: Str = Str.from_char('A');
    var c: u8 = s[1];
}


fn test_set_oob_panics() -> unit {
    var s: Str = Str.from_char('A');
    s[1] = 'B';
}


fn test_slice_oob_panics() -> unit {
    var s: Str = "ab";
    var t: Str = s[0:3];
}


fn test_to_u64_invalid_digit_panics() -> unit {
    ("12x").to_u64();
}


fn test_to_i64_overflow_panics() -> unit {
    ("9223372036854775808").to_i64();
}


fn test_merge_to_u64() -> unit {
    assert("0".to_u64() == 0u);
    assert("1".to_u64() == 1u);
    assert("1000000".to_u64() == 1000000u);
    assert("18446744073709551615".to_u64() == 18446744073709551615u);
}


fn test_merge_to_i64() -> unit {
    assert("0".to_i64() == 0);
    assert("1".to_i64() == 1);
    assert("-1".to_i64() == -1);
    assert("1000000".to_i64() == 1000000);
    assert("-1000000".to_i64() == -1000000);
    assert("9223372036854775807".to_i64() == 9223372036854775807);
    assert("-9223372036854775808".to_i64() == -9223372036854775808);
}


fn test_merge_to_u64_overflow1() -> unit {
    "18446744073709551616".to_u64();
}


fn test_merge_to_u64_overflow2() -> unit {
    "18446744073709551624".to_u64();
}


fn test_merge_to_u64_invalid_digit() -> unit {
    "123x123".to_u64();
}


fn test_merge_to_u64_empty_string() -> unit {
    "".to_u64();
}


fn test_merge_to_i64_overflow1() -> unit {
    "9223372036854775808".to_i64();
}


fn test_merge_to_i64_overflow2() -> unit {
    "9223372036854775811".to_i64();
}


fn test_merge_to_i64_overflow3() -> unit {
    "-9223372036854775809".to_i64();
}


fn test_merge_to_i64_overflow4() -> unit {
    "-9223372036854775811".to_i64();
}


fn test_merge_to_i64_invalid_digit() -> unit {
    "abcd".to_i64();
}


fn test_merge_to_i64_empty_string() -> unit {
    "".to_i64();
}


fn test_merge_e2e_str_from_char() -> unit {
    var s: Str = Str.from_char('Z');
    var c: u8 = s[0];
    assert((i64)c == 90);
}


fn test_merge_e2e_str_hex_escape() -> unit {
    var s: Str = "\x41\x42";
    var b: u8 = s[0];
    assert((i64)b == 65);
}


fn test_merge_e2e_str_literal_indexing() -> unit {
    var s: Str = "AB\n";
    var b: u8 = s[1];
    assert((i64)b == 66);
}


fn test_merge_e2e_str_oob_index_panics() -> unit {
    var v: Str = "Hello world!";
    var c1: u8 = v[-15];
    var c2: u8 = v[15];
    assert((i64)c1 + (i64)c2 == 0);
}


fn test_merge_e2e_str_oob_slice_panics() -> unit {
    var v: Str = "Hello world!";
    var s1: Str = v[-15:5];
    var s2: Str = v[15:20];
    assert((i64)s1[0] + (i64)s2[0] == 0);
}


fn test_merge_e2e_str_negative_index_and_slice() -> unit {
    var v: Str = "Hello world!";
    var c1: u8 = v[-1];
    var c2: u8 = v[-3];
    var s1: Str = v[:-1];
    var s2: Str = v[-8:8];
    var c3: u8 = s1[-1];
    var c4: u8 = s2[2];
    var sum: i64 = (i64)c1 + (i64)c2 + (i64)c3 + (i64)c4;
    assert(sum == 360);
}


fn test_merge_e2e_str_slice_syntax() -> unit {
    var v: Str = "Hello world!";
    var s1: Str = v[3:5];
    var s2: Str = v[:7];
    var s3: Str = v[4:];
    var s4: Str = v[:];
    var c1: u8 = s1[0];
    var c2: u8 = s2[6];
    var c3: u8 = s3[0];
    var c4: u8 = s4[11];
    var sum: i64 = (i64)c1 + (i64)c2 + (i64)c3 + (i64)c4;
    assert(sum == 371);
}


fn test_merge_e2e_str_strip_whitespace() -> unit {
    var v: Str = " \tHello world!\n";
    var s: Str = v.strip();
    assert(s[0] == (u8)72);
    assert(s[-1] == (u8)33);

    var w: Str = " \n\t\r";
    var empty: Str = w.strip();
    assert(empty.len() == 0u);
}


fn main() -> i64 {
    var select: u64 = read_all().strip().to_u64();

    if select == 1u { test_baseline_get_set_slice(); }
    if select == 2u { test_strip(); }
    if select == 3u { test_numeric_parse_ok(); }
    if select == 4u { test_from_u8_array(); }
    if select == 5u { test_get_oob_panics(); }
    if select == 6u { test_set_oob_panics(); }
    if select == 7u { test_slice_oob_panics(); }
    if select == 8u { test_to_u64_invalid_digit_panics(); }
    if select == 9u { test_to_i64_overflow_panics(); }
    if select == 10u { test_newstrbuf_baseline(); }
    if select == 11u { test_newstrbuf_get_oob_panics(); }
    if select == 12u { test_newstrbuf_append_char(); }
    if select == 13u { test_merge_to_u64(); test_merge_to_i64(); }
    if select == 14u { test_merge_to_u64_overflow1(); }
    if select == 15u { test_merge_to_u64_overflow2(); }
    if select == 16u { test_merge_to_u64_invalid_digit(); }
    if select == 17u { test_merge_to_u64_empty_string(); }
    if select == 18u { test_merge_to_i64_overflow1(); }
    if select == 19u { test_merge_to_i64_overflow2(); }
    if select == 20u { test_merge_to_i64_overflow3(); }
    if select == 21u { test_merge_to_i64_overflow4(); }
    if select == 22u { test_merge_to_i64_invalid_digit(); }
    if select == 23u { test_merge_to_i64_empty_string(); }
    if select == 24u { test_merge_e2e_str_from_char(); }
    if select == 25u { test_merge_e2e_str_hex_escape(); }
    if select == 26u { test_merge_e2e_str_literal_indexing(); }
    if select == 27u { test_merge_e2e_str_oob_index_panics(); }
    if select == 28u { test_merge_e2e_str_oob_slice_panics(); }
    if select == 29u { test_merge_e2e_str_negative_index_and_slice(); }
    if select == 30u { test_merge_e2e_str_slice_syntax(); }
    if select == 31u { test_merge_e2e_str_strip_whitespace(); }

    return 0;
}
